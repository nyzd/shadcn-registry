{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "render-by-scroll",
  "type": "registry:component",
  "title": "Render On Scroll",
  "dependencies": [
    "@yakad/use-interactions"
  ],
  "registryDependencies": [
    "@nq/active-on-visible"
  ],
  "files": [
    {
      "path": "./components/renderByScroll/RenderByScroll.tsx",
      "content": "\"use client\";\n\nimport React, { useEffect, useRef, useState } from \"react\";\nimport { useOnVisibilityChange } from \"@yakad/use-interactions\";\nimport { ActiveOnVisible } from \"@/components/activeOnVisible/ActiveOnVisible\";\n\nexport interface RenderByScrollProps\n    extends React.HTMLAttributes<HTMLDivElement> {\n    scrollMarginTop?: number;\n    extraRender?: number;\n    jumpToIndex?: number;\n    stopNewRenders?: boolean;\n    newChildRendered?: (index: number) => void;\n    children?: React.ReactNode;\n    ref?: React.Ref<HTMLDivElement>;\n}\n\nexport function RenderByScroll({\n    scrollMarginTop = 8, // Sticky Header Height\n    extraRender = 5,\n    jumpToIndex = 0,\n    stopNewRenders,\n    newChildRendered,\n    style,\n    children,\n    ...restProps\n}: RenderByScrollProps) {\n    const childrenArray = React.Children.toArray(children);\n\n    // Scroll Zone\n    const childRefs = useRef<Record<number, HTMLElement | null>>({});\n    const scrollTo = (i: number, smooth?: boolean) =>\n        childRefs.current[i]?.scrollIntoView({\n            behavior: smooth ? \"smooth\" : \"auto\",\n        });\n\n    // Collect Visibled Childs\n    const [visibled, setVisibled] = useState<{\n        lowest: number;\n        highest: number;\n    }>({ lowest: jumpToIndex, highest: jumpToIndex });\n    const handleOnVisible = (i: number) => {\n        if (i < visibled.lowest) setVisibled({ ...visibled, lowest: i });\n        if (i > visibled.highest) setVisibled({ ...visibled, highest: i });\n    };\n\n    // Collect Rendered Childs\n    const [rendered, setRendered] = useState<{\n        lowest: number;\n        highest: number;\n    }>({ lowest: jumpToIndex, highest: jumpToIndex });\n    const overRenderedOnLowSide = visibled.lowest - rendered.lowest;\n    const overRenderedOnHighSide = rendered.highest - visibled.highest;\n\n    // Is Visible Loading Box\n    const [isVisibleLowSideLimitSensor, setIsVisibleLowSideLimitSensor] =\n        useState<boolean>(false);\n\n    // Render new Childs if needed\n    useEffect(() => {\n        const isPriorityBYHighSide =\n            overRenderedOnHighSide < 1 ||\n            overRenderedOnHighSide - 1 <= overRenderedOnLowSide;\n        const isHighSideNewRenderRemains =\n            rendered.highest < childrenArray.length - 1;\n        const isLowSideNewRenderRemains = rendered.lowest > 0;\n        if (!stopNewRenders) {\n            if (\n                isPriorityBYHighSide &&\n                isHighSideNewRenderRemains &&\n                overRenderedOnHighSide < extraRender\n            ) {\n                const newHigh = rendered.highest + 1;\n                setRendered({ ...rendered, highest: newHigh });\n                newChildRendered?.(newHigh);\n            } else {\n                if (\n                    isLowSideNewRenderRemains &&\n                    overRenderedOnLowSide < extraRender\n                ) {\n                    if (isVisibleLowSideLimitSensor) {\n                        scrollTo(rendered.lowest);\n                    }\n                    const newLow = rendered.lowest - 1;\n                    setRendered({ ...rendered, lowest: newLow });\n                    newChildRendered?.(newLow);\n                }\n            }\n        }\n        // eslint-disable-next-line\n    }, [visibled, rendered, extraRender, stopNewRenders]);\n\n    // Scroll to jumpToIndex\n    useEffect(() => {\n        const isJumpToIndexOutOfRenderedRange =\n            jumpToIndex < rendered.lowest || jumpToIndex > rendered.highest;\n        if (isJumpToIndexOutOfRenderedRange) {\n            setVisibled({ lowest: jumpToIndex, highest: jumpToIndex });\n            setRendered({ lowest: jumpToIndex, highest: jumpToIndex });\n        }\n        const timeout = setTimeout(() => {\n            scrollTo(jumpToIndex, true);\n        }, 100);\n        return () => clearTimeout(timeout);\n        // eslint-disable-next-line\n    }, [jumpToIndex]);\n\n    const onvisibRef = useOnVisibilityChange<HTMLDivElement>((visible) => {\n        setIsVisibleLowSideLimitSensor(visible);\n    });\n\n    return (\n        <div {...restProps} style={{ minHeight: \"100vh\", ...style }}>\n            {rendered.lowest > 0 && (\n                <div\n                    ref={onvisibRef}\n                    style={{\n                        marginBottom: `${scrollMarginTop}rem`,\n                    }}\n                />\n            )}\n            {childrenArray.map(\n                (child, i) =>\n                    i >= rendered.lowest &&\n                    i <= rendered.highest && (\n                        <ActiveOnVisible\n                            key={i}\n                            ref={(el) => {\n                                childRefs.current[i] = el;\n                            }}\n                            style={{\n                                scrollMarginTop: `${scrollMarginTop}rem`,\n                            }}\n                            onVisibilityChange={(visible) => {\n                                visible && handleOnVisible(i);\n                            }}\n                        >\n                            {child}\n                        </ActiveOnVisible>\n                    ),\n            )}\n        </div>\n    );\n}\n",
      "type": "registry:component"
    }
  ]
}